---
title: '[GraphQL] エラーの型もスキーマとして提供してしまおうという試み'
emoji: '🦤'
type: 'tech' # tech: 技術記事 / idea: アイデア
topics: ['graphql', 'gqlgen']
published: false
---

# はじめに

業務で GraphQL でエラーの設計をする機会があり、いろいろと調査・検討した結果、なかなか良いと思えるものができたので紹介します。

サーバ寄りのお話になります。GraphQL のエラーの扱いに迷っているサーバサイドエンジニアの方の参考になれば幸いです。

# コンテキスト

プロジェクトで採用している技術のなかで、今回の記事の解説で登場するものを以下に抜粋します。

| 採用技術                                                                | 用途                                                                                                              |
| ----------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------- |
| [Hasura](https://hasura.io/)                                            | メインの GraphQL サーバとして使用                                                                                 |
| [gqlgen](https://github.com/99designs/gqlgen)                           | Hasura の [Remote Schemas](https://hasura.io/docs/latest/remote-schemas/index/) となる GraphQL サーバの構築に使用 |
| [Apollo Client](https://github.com/apollographql/apollo-client)         | GraphQL クライアント                                                                                              |
| [graphql-codegen](https://github.com/dotansimha/graphql-code-generator) | Apollo Client で使うコードのコードの自動生成に使用                                                                |

基本的に API は Hasura が自動生成した GraphQL API を使っています。一部、複雑なバリデーションや外部 API へのリクエストが必要なため、自前の GraphQL API を開発し、それを Hasura の Remote Schemas としています。今回検討したのはこの Remote Schemas のエラーに関してでした。具体的には、API のエラーメッセージをフロントエンドに表示させることを考慮した場合にサーバから返すエラーのフォーマットをどうしようか、ということを検討していきました。

「Hasura」「Remote Schemas」に関してはこの記事では解説しませんのでご了承下さい。そこまで深く踏み込んだ話はしないので、なんとなくの理解でも記事の趣旨は把握できるかと思います。

もし詳しく知りたい方は解説記事が既に上がっていますのでこちらをご覧ください。

https://qiita.com/maaz118/items/9e198ea91ad8fc624491

https://zenn.dev/msorz/articles/47b47acedb3c5e

# 調査したこと

エラーの表現方法の検討にあたって参考にさせていただいた資料・事例を載せておきます。すべて紹介しきると長いので、かいつまんで紹介します。

## GraphQL 標準仕様で定められたフォーマット

https://spec.graphql.org/October2021/#sec-Errors

GraphQL の標準仕様 (October 2021 Edition) で決まっているエラーのフォーマットです。
エラーレスポンスの例と各フィールドが持つべき意味は下記のとおりです。

```js
{
  "errors": [
    {
      // 開発者向けのエラーメッセージ
      "message": "Name for character with ID 1002 could not be fetched.",
      // もとのGraphQLクエリのなかでどこにエラーが起きたか
      "locations": [{ "line": 6, "column": 7 }],
      // レスポンスのどこにエラーが発生しているか
      "path": ["hero", "heroFriends", 1, "name"],
      // 何でも詰め込んでいいanyなフィールド
      "extensions": {
        "code": "CAN_NOT_FETCH_BY_ID",
        "timestamp": "Fri Feb 9 14:33:09 UTC 2018"
      }
    }
  ]
}
```

## extensions に独自のフォーマットを適用する

GraphQL 標準のエラーの extensions フィールドをアプリケーション独自のものに拡張して使うやり方です。以下の記事を参考にさせていただきました。

https://note.com/tabelog_frontend/n/n4fc8d4e134d5#c34ea47a-7345-45b0-b0ce-e607579e2169

https://techblog.zozo.com/entry/graphql_error_handling

エラーレスポンスは下記のようなものが返却されます。

```json
// 引用元: https://note.com/tabelog_frontend/n/n4fc8d4e134d5#c34ea47a-7345-45b0-b0ce-e607579e2169
{
  "errors": [
    {
      "message": "Invalid data inputted.",
      "extensions": {
        "code": "UNPROCESSABLE_ENTITY",
        "userMessage": "入力項目にエラーがあります",
        "errorDetails": [
          {
            "message": "hoge@example.com はすでに存在します",
            "attribute": "email"
          },
          {
            "message": "お名前の入力は必須です",
            "attribute": "lastName"
          }
        ]
      }
    }
  ]
}
```

Apollo Server のドキュメントにもこれに近い内容が記載されていました。

https://www.apollographql.com/docs/apollo-server/data/errors/#custom-errors

また、社内の他のプロジェクトでもこのようなエラーの返し方をしているところが多かったです。割と一般的な扱い方なのかなという印象を受けました。

## Result 型にエラーのフィールドを作る

通常のレスポンスフィールドにエラー用のフィールドを作ってしまうパターンです。こちらは [Shopify の GraphQL API で採用されている](https://shopify.dev/api/admin-graphql/2022-07/objects/UserError)やり方です。

https://ichyaku.com/graphql-api-design/#i-2

クエリ上でエラーを書くときにエラーを明示的に取ってくるようにします。Shopify の API では mutation の input が不正な場合は `[UserError!]!` 型の `userErrors` というフィールドでそのエラー内容を表現しています。REST だとステータスコード 400 や 422 で扱うような情報をこのフィールドに込めているようですね。

GraphQL 標準の `errors` ではなく `data` の中身でエラーを表現する点で先に紹介した `extensions` を拡張するやり方と大きく異なります。

```graphql
# 引用元: https://shopify.dev/api/admin-graphql/2022-07/mutations/fulfillmentCancel#top
mutation fulfillmentCancel($id: ID!) {
  fulfillmentCancel(id: $id) {
    fulfillment {
      # Fulfillment fields
    }
    userErrors {
      field
      message
    }
  }
}
```

レスポンスは下記のようになります。「トップレベルの `errors` フィールドが返ってきていない」「`userErrors` が空配列である」を判定して成功レスポンスであると判断します。

```json
{
  "data": {
    "fulfillmentCancel": {
      "fulfillment": {
        "id": "gid://shopify/Fulfillment/237894043",
        "status": "CANCELLED"
      },
      "userErrors": []
    }
  }
}
```

## Result 型を成功レスポンスとエラーレスポンスの union 型として定義する

レスポンスの型を union を使って定義するやり方です。下記の記事を参考にしました。

https://techblog.gaudiy.com/entry/2022/02/17/215331

こちらの例でもクライアント起因のエラーを `data` で返すような仕様になっています。先に紹介した Shopify の GraphQL API と大きく違うのは、エラーの型を `UserError` のような画一的な型ではなく、それぞれ別の型として定義している点です。

```graphql
# 引用元: https://techblog.gaudiy.com/entry/2022/02/17/215331
type Mutation {
  """
  シリアルコードの入力チェック
  """
  checkSerialCode(serialCode: String!): CheckSerialCodeResult!
}

union CheckSerialCodeResult =
    CheckSerialCodeSuccess
  | CheckSerialCodeNotApplicable
  | CheckSerialCodeAlreadyUsed
  | CheckSerialCodeUsageLimitExceeded

"""
成功
"""
type CheckSerialCodeSuccess {}

"""
エラー: 該当しないシリアルコードの場合
"""
type CheckSerialCodeNotApplicable {}

"""
エラー: 既に使用されているシリアルコードの場合
"""
type CheckSerialCodeAlreadyUsed {}

"""
エラー: シリアルコードの入力回数が上限を超えている場合
"""
type CheckSerialCodeUsageLimitExceeded {}
```

クライアントは `__typename` の値を見てどの型の Result が返ったかを判断し、それぞれの場合でハンドリングします。

```graphql
mutation Mutation($serialCode: String!) {
  checkSerialCode(serialCode: $serialCode) {
    __typename
    ... on CheckSerialCodeSuccess {
    }
    ... on CheckSerialCodeNotApplicable {
    }
    ... on CheckSerialCodeAlreadyUsed {
    }
    ... on CheckSerialCodeUsageLimitExceeded {
    }
  }
}
```

# 基本方針

ここまでの調査とプロジェクトのコンテキストを踏まえ、以下のように検討の方針を立てました。

## errors[i].message は開発者向けの文言にする。このフィールドはユーザには見せない

- Hasura が DB やサーバからのメッセージをそのまま出してしまうので sidecar でもそれにならう
- そもそも GraphQL 標準仕様では開発者のためのメッセージであると明記されている

> Every error must contain an entry with the key message with a string description of the error intended for the developer as a guide to understand and correct the error.

## 可能ならエラーのモデルも GraphQL スキーマで定義する

- graphql-codegen の恩恵を受けられるため
- extensions を拡張していくやり方だとスキーマ定義出来ないので FE と BE 両方で型を保つ必要がある

## ユーザに見せていいエラーかどうかレスポンスだけをみて判断できるようにしたい

- BE からのエラーメッセージを画面に表示させたいので

## エラーの分類

### ユーザエラー

### 例外エラー

# 最終的な判断

## 判断内容

## 実装した GraphQL スキーマ

# gqlgen で union を実装するとこんな感じ

# まとめ
