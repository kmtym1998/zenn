---
title: 'ユニーク制約が作れないけど、DB レベルで多重登録を防ぎたかったとき'
emoji: '👋'
type: 'tech' # tech: 技術記事 / idea: アイデア
topics: ['postgresql', 'database']
published: false
---

# はじめに

- Web アプリケーションのデータ整合性を担保するのはだいじ
- 一意制約を担保するためには RDB のユニーク制約を使うことが有効な場面が多い
- いろいろな理由で DB レベルでユニーク制約が作れないことはあると思う
  - 設計上難しかったり、リリースしてから後付けでユニークかける必要がでてきたりなど
  - データクレンジングをしてユニーク制約をつけるのが容易であればそうすれば良いが、そんなにうまく行かないことが多い
- 自分もユニーク制約が使えないなかでの一意制約担保に悩んでいた
- 本記事ではユニーク制約を使わずにデータの一意性の担保をする実装方法を紹介したい
- PostgreSQL を前提に書いています

# 説明のための例

- 以降の説明のために簡単なタスクテーブルを例として使います
- わかりやすさのために一部非正規化しています

```sql
CREATE TABLE public.tasks (
  id serial NOT NULL,
  title varchar(255) NOT NULL,
  detail text,
  progress_status varchar(255) NOT NULL,
  PRIMARY KEY (id)
);
```

- 以下のような制約があります
  - タスクは進捗ステータスを持ち、TODO, DOING, DONE の 3 値のみとりうる
  - タスクの新規作成時は必ず TODO である
  - TODO なタスクは 1 件しか存在してはいけない

# 問題となったこと

- TODO なタスクの多重登録ができてしまう状態であった
  - フロントエンドでダブルサブミット対策はしていたが、挙動が不安定だった (一部端末依存の挙動があった)
    - フロントエンドでさらなる対策はしたものの、あくまでも保険的対応である
    - 悪意のあるユーザが curl で API を叩くなどできてしまう
    - 別のユーザが同時にサブミットする可能性もある
  - サーバ側でバリデーションできていることが理想である

ユニーク制約が作れないため API 内部に以下のようなロジックを追加しました。

```sql
-- ① 重複したタスクがないかどうかチェック
SELECT id FROM tasks WHERE progress_status = 'TODO' LIMIT 1;

-- ② 重複がなければ新規タスク作成
INSERT INTO tasks (title, progress_status) VALUES ('タスクのタイトル', 'TODO');
```

しかしこれでは重複を完全に防げません。① の SELECT 文を叩いてから ② の INSERT 文の処理が完了するまでに若干のインターバルが存在するためです。このインターバルの間に別のリクエストの処理が並列していると、重複チェックのロジックをすり抜けてしまいます。

![](https://storage.googleapis.com/zenn-user-upload/d51abb78d613-20231224.png)

今回挙げたシンプルな例の場合、このインターバルは小さいので重複が発生する可能性は低いかもしれません。ですが、業務で扱うような複雑なアプリケーションでは重複チェックのために複雑なクエリを実行する必要があったり、① と ② の間に重厚なロジック・外部通信等が挟まったりします。そうなるとインターバルが長くなりと意図しない多重登録が発生する可能性は高くなります。

# 解決方法

## トランザクション分離レベル シリアライザブルを使う

このような問題の対策として、直列化を担保したトランザクションを使うことが有効です。PostgreSQL (および 標準 SQL) ではトランザクション分離レベルは「リードアンコミッティド」「リードコミッティド」「リピータブルリード」「シリアライザブル」の 4 つが実装されています。また、PostgreSQL 公式ドキュメントには 2 つ以上のセッションでデータ操作が競合するときに発生しうる問題と、トランザクション分離レベルの関係性が記述されています。

https://www.postgresql.jp/docs/15/transaction-iso.html

| 分離レベル             | ダーティリード                          | 反復不能読み取り | ファントムリード                        | 直列化異常 |
| ---------------------- | --------------------------------------- | ---------------- | --------------------------------------- | ---------- |
| リードアンコミッティド | 許容されるが、PostgreSQL では発生しない | 可能性あり       | 可能性あり                              | 可能性あり |
| リードコミッティド     | 安全                                    | 可能性あり       | 可能性あり                              | 可能性あり |
| リピータブルリード     | 安全                                    | 安全             | 許容されるが、PostgreSQL では発生しない | 可能性あり |
| シリアライザブル       | 安全                                    | 安全             | 安全                                    | 安全       |

それぞれのトランザクション分離レベルで具体的にどういう挙動をするのかについては、こちらの記事でわかりやすく解説されています。

https://zenn.dev/bellwood4486/articles/postgresql-trans-iso-level

上記の表の通り、直列化を担保するにはトランザクション分離レベルに[シリアライザブル](https://www.postgresql.jp/docs/15/transaction-iso.html#XACT-SERIALIZABLE)を使います。先程の重複チェックのための SELECT と INSERT をシリアライザブルのトランザクションで括ることで直列化が担保されます。

```sql
-- ① シリアライザブルでトランザクション開始
BEGIN TRANSACTION ISOLATION LEVEL SERIALIZABLE;

-- ② 重複したタスクがないかどうかチェック
SELECT id FROM tasks WHERE progress_status = 'TODO' LIMIT 1;

-- ③ 重複がなければ新規タスク作成
INSERT INTO tasks (title, progress_status) VALUES ('タスクのタイトル', 'TODO');

-- ④ トランザクション終了
COMMIT;
```

並列に (直列でない状態で) トランザクションが走った場合は ③ または ④ で直列化失敗のエラー (`could not serialize access...`) が発生します。一方のトランザクションがコミットされた時点で、他方のトランザクション内で INSERT が完了していればその次の COMMIT で、INSERT が完了していなければ ③ の INSERT でエラーが返ります。問題点で挙げた処理フローにトランザクションを差し込んだ場合は前者にあたるので COMMIT でエラーが返ってくれるので、多重登録は発生しません。

![](https://storage.googleapis.com/zenn-user-upload/a8b1dc34675e-20231224.png)

また、エラーハンドリングにも気を配る必要があります。直列化失敗をサーバエラーとするか、クライアントエラーとするか、正常レスポンスとするか、リトライするかなど、検討の余地があります。

## 行ロックを使う

# まとめ

https://speakerdeck.com/saiya_moebius/rdbms-in-action?slide=9
