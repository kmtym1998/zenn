---
title: '[PostgreSQL] ユニーク制約が作れなくても DB レベルで重複登録を防ぎたくて検討したこと'
emoji: '👋'
type: 'tech' # tech: 技術記事 / idea: アイデア
topics: ['postgresql', 'database']
published: false
---

# はじめに

Web アプリケーションにおいて、データの整合性を担保することは重要です。とくにデータの一意性を担保することは、アプリケーションの信頼性を保つために不可欠です。一般的に、データの一意性を保証するのに RDB のユニーク制約が使用されることが多いです。しかし、さまざまな理由からデータベースレベルでユニーク制約を設定することが困難な場合もあります。設計上難しかったり、機能のリリース後に一意性を保証する必要が生じた場合などです。データのクレンジングを行ってユニーク制約を設定することが理想ですが、それが簡単に行かないことが多いと思います。

私自身も、ユニーク制約を使用できない状況でデータの一意性をどう担保するかについて悩んでいました。この記事ではユニーク制約を使わずにデータの一意性を保証する方法について、実装例を交えて紹介します。また、ここでは PostgreSQL の使用を前提に説明しています。

# 説明のための例

まずは、以下のような簡単なタスクテーブルを例にします。説明をわかりやすくするため、あえて一部のデータを非正規化しています。

```sql
CREATE TABLE public.tasks (
  id serial NOT NULL,
  title varchar(255) NOT NULL,
  detail text,
  progress_status varchar(255) NOT NULL,
  PRIMARY KEY (id)
);
```

このタスクテーブルには以下のような制約があります。

- タスクには進捗ステータスがあり、取り得る値は `TODO`, `DOING`, `DONE` の 3 値のみ
- タスクの新規作成時には、その進捗ステータスは必ず `TODO` になる
- `TODO` なタスクは同時に 1 件しか存在してはなりません。

# 問題となったこと

ダブルサブミットによって `TODO` なタスクが多重登録できる状態であったことです。もともとフロントエンドでダブルサブミット対策を施していましたが、端末によってうまく動作しないケースがあるなど、挙動が不安定でした。フロントエンドでさらに対策を講じたとしても、それはあくまで保険的なものです。悪意のあるユーザが直接 API を叩くこと、同一ユーザによる別のタブ操作、複数のユーザによる同時にサブミットするなど、これをすり抜ける方法はいくつか考えられます。サーバ側でこのような重複を防ぐためのバリデーションが行われていることが理想的です。

この問題はユニーク制約を設けることでは解決できない問題であったため、API 内部に以下のようなロジックを追加しました。

```sql
-- ① 重複したタスクがないかどうかチェック
SELECT id FROM tasks WHERE progress_status = 'TODO' LIMIT 1;

-- ② 重複がなければ新規タスク作成
INSERT INTO tasks (title, progress_status) VALUES ('タスクのタイトル', 'TODO');
```

しかしこれでは重複を完全に防げません。① の SELECT 文を叩いてから ② の INSERT 文の処理が完了するまでに若干のインターバルが存在するためです。このインターバルの間に別のリクエストの処理が並列していると、重複チェックのロジックをすり抜けてしまいます。

![](https://storage.googleapis.com/zenn-user-upload/d51abb78d613-20231224.png)

今回のようなシンプルな例の場合、このインターバルは小さいので重複が発生する可能性は低いかもしれません。ですが、業務で扱うような複雑なアプリケーションでは重複チェックのために複雑なクエリを実行する必要があったり、① と ② の間に重厚なロジック・外部通信等が挟まったりします。そうなるとインターバルが長くなり、サブミットボタン連打などによる意図しない多重登録が発生する可能性は高くなります。

問題となっているのは DB へのアクセスが直列になっていないことです。タスク追加前の重複チェックは、直前のタスク追加よりも必ず後にならなければなりません (上図の例だと、`重複チェックA` → `新規作成A` → `重複チェックB` → `新規作成B` となってほしい)。

# 検討した解決方法

## トランザクション分離レベル シリアライザブルを使う

このような問題の対策として、直列化を担保したトランザクションを使うことが有効です。PostgreSQL (および 標準 SQL) ではトランザクション分離レベルは「リードアンコミッティド」「リードコミッティド」「リピータブルリード」「シリアライザブル」の 4 つが実装されています。また、PostgreSQL 公式ドキュメントには 2 つ以上のセッションでデータ操作が競合するときに発生しうる問題と、トランザクション分離レベルの関係性が記述されています。

https://www.postgresql.jp/docs/15/transaction-iso.html

| 分離レベル             | ダーティリード                          | 反復不能読み取り | ファントムリード                        | 直列化異常 |
| ---------------------- | --------------------------------------- | ---------------- | --------------------------------------- | ---------- |
| リードアンコミッティド | 許容されるが、PostgreSQL では発生しない | 可能性あり       | 可能性あり                              | 可能性あり |
| リードコミッティド     | 安全                                    | 可能性あり       | 可能性あり                              | 可能性あり |
| リピータブルリード     | 安全                                    | 安全             | 許容されるが、PostgreSQL では発生しない | 可能性あり |
| シリアライザブル       | 安全                                    | 安全             | 安全                                    | 安全       |

それぞれのトランザクション分離レベルで具体的にどういう挙動をするのかについては、こちらの記事でわかりやすく解説されています。

https://zenn.dev/bellwood4486/articles/postgresql-trans-iso-level

上記の表の通り、直列化を担保するにはトランザクション分離レベルに[シリアライザブル](https://www.postgresql.jp/docs/15/transaction-iso.html#XACT-SERIALIZABLE)を使います。先程の重複チェックのための SELECT と INSERT をシリアライザブルのトランザクションで括ることで直列化が担保されます。

```sql
-- ① シリアライザブルでトランザクション開始
BEGIN TRANSACTION ISOLATION LEVEL SERIALIZABLE;

-- ② 重複したタスクがないかどうかチェック
SELECT id FROM tasks WHERE progress_status = 'TODO' LIMIT 1;

-- ③ 重複がなければ新規タスク作成
INSERT INTO tasks (title, progress_status) VALUES ('タスクのタイトル', 'TODO');

-- ④ トランザクション終了
COMMIT;
```

並列に (直列でない状態で) トランザクションが走った場合は ③ または ④ で直列化失敗のエラー (`could not serialize access...`) が発生します。一方のトランザクションがコミットされた時点で、他方のトランザクション内で INSERT が完了していればその次の COMMIT で、INSERT が完了していなければ ③ の INSERT でエラーが返ります。問題点で挙げた処理フローにトランザクションを差し込んだ場合は前者にあたるので COMMIT でエラーが返ってくれるので、多重登録は発生しません。

![](https://storage.googleapis.com/zenn-user-upload/a8b1dc34675e-20231224.png)

このパターンで実装した場合、直列化失敗で発生したエラーのハンドリングにも気を配る必要があります。サーバエラーとするか、クライアントエラーとするか、正常レスポンスとするか、リトライするかなど、検討の余地があります。整合性が強いからといってなんでもシリアライザブルで実装すると、不要な直列化失敗エラーを引き起こして UX を下げてしまうことがあるため注意が必要です。また、シリアライザブルは安全性が高いぶん他の分離レベルと比べて相対的に性能は低いとされています。

## 排他ロックを使う

直列化を担保したトランザクションは排他ロックを使うことによっても実現可能です。

今回実現したいのは多重にレコードが作成されることを防ぐことですが、PostgreSQL では (作成予定の) 存在しない行に対しての行ロックはできないようです。特定の行に対してロックを行えない場合はロックの範囲を広げることが有効な場合があります。テーブルごとロックしてしまえば、SELECT した結果をもとに INSERT する今回のケースでも、直列化を担保することができるようになります。

```sql
-- ① READ COMMITTED または READ UNCOMMITTED でトランザクション開始
 BEGIN TRANSACTION ISOLATION LEVEL READ COMMITTED;

-- ② tasks テーブルをまるごとロック
LOCK TABLE tasks;

-- ③ 重複したタスクがないかどうかチェック
SELECT id FROM tasks WHERE progress_status = 'TODO' LIMIT 1;

-- ④ 重複がなければ新規タスク作成
INSERT INTO tasks (title, progress_status) VALUES ('タスクのタイトル', 'TODO');

-- ⑤ トランザクション終了
COMMIT;
```

上記のように実装すると テーブルにロックをかけるときに他のロックが解放されるのを待ってくれます。トランザクションが終了 (コミット or ロールバック) されると、そのロックが解放されるため、重複チェックが直前のタスク追加より後になることが保証されます。また、ロックをかけるトランザクションの分離レベルは「リードアンコミッティド」または「リードコミッティド」を選択する必要があります。「リピータブルリード」や「シリアライザブル」を選択してしまうと、並列して発生した他のトランザクションで作成されたレコードが読み取れなくなってしまい、③ の重複チェックが機能しなくなってしまいます。

![](https://storage.googleapis.com/zenn-user-upload/aea31fb19d9f-20231229.png)

テーブルロックにはロックモードというオプションが存在します。この記事では紹介しきれないので、詳しくは他の記事や公式ドキュメントをご覧ください。

https://www.postgresql.jp/docs/15/sql-lock.html

https://qiita.com/behiron/items/571562ea33b8212a4c32

ロックをかける際は、デッドロックにも気を配る必要があります。デッドロックとは、2 つ以上のトランザクションが互いのロック解放を待つ状態となってしまい、いずれもの処理が止まってしまう状態のことをいいます。`lock_timeout` を設定してロックの解放待ち時間に上限を設けるなどしておくと安心かと思います。

https://qiita.com/mkyz08/items/9321fb8662c7ee09e14a

# まとめ

DB でユニーク制約を設定できない場合にデータの重複を防ぐために検討した実装パターンを紹介しました。銀の弾丸的な方法はなく、どのパターンでも注意すべきポイントが生じることに注意が必要です。なかなか考慮が漏れやすい部分かもしれませんが、プロダクトが扱うデータの特性によってはシビアに考えないといけないケースがあるかなと思います。

# 参考資料

https://speakerdeck.com/saiya_moebius/rdbms-in-action?slide=9

https://speakerdeck.com/mpyw/postgres-niokerutoranzakusiyonfen-li-reberu
