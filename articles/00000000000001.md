---
title: 'Go の Cloud Functions でファイルの読み取りを行うのにひと工夫必要だった'
emoji: '🔖'
type: 'tech' # tech: 技術記事 / idea: アイデア
topics: ['Go', 'GCP']
published: false
---

# 概要

- 記事の概要
  - fs 使いたかったら ./serverless_function_source_code 配下を見ろ
  - buildpack を使えば同じ挙動を再現できる

# 経緯

- ローカル環境では functionframework を使っていた
- GCS に置くほどでもない JSON データを Cloud Functions のソースと同じところにおいていた
- 普通に `os.ReadFile` したらそんなファイルないと言われた
- どう見てもパスが間違っているとかではない。ローカル環境では読み込めている。

# 原因

- ドキュメント を見てみた

https://cloud.google.com/functions/docs/concepts/execution-environment#memory-file-system

> 注: Cloud Functions 実行環境では、関数のソースコードのルート ディレクトリは作業ディレクトリ（.）になります。ただし、Go ランタイムの場合は、関数ランタイムのルート ディレクトリが ./serverless_function_source_code にある現在の作業ディレクトリの下になります。

- 😅 ...Go だけ不思議なディレクトリが切られてて、その配下にある
- Cloud Function の実行環境でディレクトリを読み取ったりしてみた。確かにある

# 対策

- 前提として、CF のローカル環境を建てるのにやり方が 2 つある
  - functionframework ← 筆者はこちらを採用。簡単なので。
  - buildpack を使う ← こっちはソースコードの変更のたびにコンテナをビルドして立ち上げ直さないといけないので開発体験がイマイチ。
- ローカル環境でも Cloud Functions の実行環境上でも動くようにするには
- functionsframework を使い続ける場合
  - パスを環境変数化する
  - 環境の違いを意識したコードが生まれてしまう。↑ の仕様を知らないとなぜこんなことをしているのかわかりにくい
  - メリットは手軽なこと。開発体験がよい
- buildpack を使う
  - 同じように os.ReadFile したりしてみたら ./serverless_function_source_code にソースコードがあった。
  - 他のディレクトリ構成も Cloud Functions と同じだった。
  - ほかは知らんが、fs に関しては Cloud Functions と同じ環境だと言えるので、そこ向けに書いてあげればいい
  - CLoud Functions の実行環境との違いを意識しなくていい点はメリット
  - デメリットは開発体験がイマイチなこと

# ついでに

## fs の中身深ぼってみた

## 他の言語だとどうなの？
